1. x^0是保留，x^1是取反

   - e.g:x=0x789ABC21,除了x的最低有效字节外，其他的位都取补，最低有效位字节保持不变，结果为x^~0xFF

2. 逻辑右移：左端补k个0；算数右移：左端补k个最高有效位的值

   实际上，几乎所有的编译器/机器组合都对有符号数使用算数右移，且对于无符号数，必须是逻辑右移

   位移量是通过计算k mod w得到的，也就是说对32位数左/右移32位相当于不进行位移

3. 补码编码：最高有效位设为符号位，运算时加负号，其他不变

   - e.g:(1011)B=-1 * 2^3 + 1 * 2^1 + 1 = -5

   -1与无符号数最大值有相同的位表示：全是1的串

4. 强制类型转换的结果保持位值不变，只是改变了解释这些位的方式

5. 补码转换为无符号数：当x<0时，取x + 2^w；当x>=0时，取x

   无符号数转换为补码：当x<=TMaxw时，取x；当x>TMaxw时，取x - 2^w

   当执行一个运算时，如果它的一个运算数时有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算，如 -1<0U 将被判断为假

6. 要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加0，这种运算被称为零扩展

   要将一个补码数字转换为一个更大的数据类型，可以执行一个符号扩展，在表示中添加最高有效位的值

   从一个数据大小到另一个数据大小的转换，以及无符号和有符号数字之间的转换的相对顺序能够影响一个程序的行为，如把short转换成unsigned时，要先改变大小，再完成从有符号到无符号的转换，而不是先有符号转无符号，再改变大小，两者结果不同

7. 当将一个w位的数x截断为一个k位数字时，我们会丢弃高w-k位，即x' = x mod 2^k

   补码截断要将最高位转换为符号位，其他不变，即x' = U2Tk(x mod 2^k)

   以4位数值截断到3位数值为例，无符号数直接丢弃最高位，补码要先转成4位无符号数，再与8取模，结果与2^2=4比较，小于4保留，大于4转补码要减8，得到结果

8. stdio.h中数据类型size_t定义为unsigned int

   Java中>>定义为算数右移，>>>定义为逻辑右移

9. 无符号数加法：当x+y < 2^w时，取x + y；当2^w <= x+y < 2^(w+1)时，取x + y - 2^w，此为溢出

   模数加法形成了一种数学结构，称为阿贝尔群，它是可交换的和可结合的，有一个单位元0，对每个元素有一个加法逆元，即对于每个值x，必然有某一个值-x满足-x+x=0（p.s.有点线性空间的感觉了）

   无符号数求反：当x等于0时，取x；当x>0时，取2^w - x

10. 补码加法：当2^(w-1) <= x+y时，取x + y- 2^w，此为正溢出；当-2^(w-1) <= x+y < 2^(w-1)时，取x + y；当x+y < -2^(w-1)时，取x + y + 2^w，此为负溢出

    两个数的w位补码之和与无符号之和有完全相同的位级表示，所以实际上大多数计算机使用同样的机器指令来执行无符号或者有符号加法

    补码取反(补码非)：当x = TMinw时，取TMinw；当x > TMinw时，取-x

    执行位级补码非的第一种方法是对每一位求补，再对结果加1，即对于任意整数值x，-x和~x+1得到的结果完全一样

    第二种方法是假设k是最右边的1的位置，对位k左边的所有位取反，如x=(1*1*00)B=-4，-x=(0*1*00)B=4

11. 无符号乘法：两个w位的数相乘可能需要2w位来表示，其中低w位表示的值即为x * y，即将一个无符号数截断为w位，即x * y = (x * y) mod 2^w

    补码乘法：x * y = U2Tw((x * y) mod 2^w)

    对于无符号和补码乘法来说，乘法运算的位级表示都是一样的

    由于整数乘法比位移和加法的代价要大得多，许多C语言编译器试图以位移、加法和减法的组合来消除很多整数乘以常数的情况，如x * 14会重写为(x<<3)+(x<<2)+(x<<1)或(x<<4)-(x<<1)

12. 整数除法总是舍入到零，如x=3.1会舍入为3，y=-3.1会舍入为-3

    除以2^k的无符号除法：x>>k后向下取整，如x=(0011000000110100)B=12340，x>>8=(0000000000110000)B=48，12340/2^8=48.203125

    除以2^k的补码除法：正数与无符号除法相同，下举负数情况

    - 法一：x>>k后向下取整，注意是算数右移，向下取整而不是向零取整
    - 法二：(x+(1<<k)-1)>>k后向上取整

